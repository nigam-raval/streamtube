services:
    app-dev:
      build:
        context: ./
        dockerfile: ./backend/app/Dockerfile
      image: app-dev-node
      ports:
        - 127.0.0.1:8001:${PORT}
      volumes:
        - ./:/workspace/
      working_dir: /workspace/backend/app
      stdin_open: true
      tty: true
      command: pnpm dev
      depends_on:
        mongodb:
          condition: service_healthy
        postgres:
          condition: service_healthy
        bucket-storage:
          condition: service_healthy
      networks:
        - streamtube-dev


    video-transcoder-worker-dev:
      build:
        context: ./
        dockerfile: backend/videoTranscoder/Dockerfile.dev
      image: video-transcoder-worker-dev-node
      volumes:
        - ./:/workspace/
      working_dir: /workspace/backend/videoTranscoder
      depends_on:
        bucket-storage:
          condition: service_healthy
        rabbitmq:
          condition: service_healthy
      stdin_open: true
      tty: true
      networks:
        - streamtube-dev
      # DEV ONLY: Simulate KEDA behavior.
      # In Production (K8s), KEDA triggers this container only when messages exist.
      # In Docker Compose, KEDA is absent, so we use this loop to keep the 
      # container alive and polling for new work.  
      command: >
        sh -c "  
          while true; do
            echo 'Worker checking for jobs';
            pnpm start;
            echo 'Done or Empty. Sleeping 5s';
            sleep 5;
          done
        "
      # deploy:
      #     resources:
      #       limits:
      #         cpus: '8.0'  # Allocating logical CPUs
      #         memory: 10G    # Allocating memory

    mongodb:
      image: mongo:8.2
      restart: always
      environment:
        MONGO_INITDB_ROOT_USERNAME: ${DB_ROOT_USERNAME}
        MONGO_INITDB_ROOT_PASSWORD: ${DB_ROOT_PASSWORD}
      ports:
        - 127.0.0.1:27017:27017
      networks:
          - streamtube-dev
      volumes:
        - mongodb-dev-data:/data/db
      healthcheck:
        test: ["CMD", "mongosh", "--quiet", "-u", "${DB_ROOT_USERNAME}", "-p", "${DB_ROOT_PASSWORD}", "--authenticationDatabase", "${AUTH_SOURCE}" , "--eval", "db.adminCommand('ping').ok"]
        interval: 10s
        timeout: 5s
        retries: 5
        start_period: 10s

    postgres:
      image: postgres:18.1
      restart: always
      environment:
        POSTGRES_USER: ${PGUSER}
        POSTGRES_PASSWORD: ${PGPASSWORD}
        POSTGRES_DB: ${PGDATABASE}
      ports:
        - "127.0.0.1:5432:5432"
      networks:
          - streamtube-dev
      volumes:
        - pg-dev-data:/var/lib/postgresql
      healthcheck:
        test: ["CMD-SHELL", "pg_isready -U ${PGUSER} -d ${PGDATABASE}"]
        interval: 10s
        timeout: 5s
        retries: 5
        start_period: 10s

    bucket-storage:
      image: minio/minio:latest
      environment:
        MINIO_ROOT_USER: ${STORAGE_ACCESS_KEY}
        MINIO_ROOT_PASSWORD: ${STORAGE_SECRET_KEY}
        # for event notfication
        MINIO_NOTIFY_AMQP_ENABLE_rabbitmq1: ${MINIO_NOTIFY_AMQP_ENABLE_rabbitmq1}
        MINIO_NOTIFY_AMQP_URL_rabbitmq1: ${MINIO_NOTIFY_AMQP_URL_rabbitmq1}
        MINIO_NOTIFY_AMQP_EXCHANGE_rabbitmq1: ${MINIO_NOTIFY_AMQP_EXCHANGE_rabbitmq1}
        MINIO_NOTIFY_AMQP_EXCHANGE_TYPE_rabbitmq1: ${MINIO_NOTIFY_AMQP_EXCHANGE_TYPE_rabbitmq1}
        MINIO_NOTIFY_AMQP_ROUTING_KEY_rabbitmq1: ${MINIO_NOTIFY_AMQP_ROUTING_KEY_rabbitmq1}
        MINIO_NOTIFY_AMQP_DELIVERY_MODE_rabbitmq1: ${MINIO_NOTIFY_AMQP_DELIVERY_MODE_rabbitmq1}
        MINIO_NOTIFY_AMQP_DURABLE_rabbitmq1: ${MINIO_NOTIFY_AMQP_DURABLE_rabbitmq1}
      depends_on:
        rabbitmq:
          condition: service_healthy
      ports:
        - 127.0.0.1:9000:9000  # HTTP port for MinIO
        - 127.0.0.1:9001:9001  # Port for MinIO Web UI (optional)
      networks:
          - streamtube-dev
      volumes:
        - minio-dev-data:/data
      command: server /data --console-address ":9001"
      restart: always
      healthcheck:
        test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
        interval: 5s
        timeout: 5s
        retries: 5
        start_period: 10s

    bucket-storage-init:
      image: minio/minio:latest
      depends_on:
        bucket-storage:
          condition: service_healthy
      environment:
        MINIO_ROOT_USER: ${STORAGE_ACCESS_KEY}
        MINIO_ROOT_PASSWORD: ${STORAGE_SECRET_KEY}
        STORAGE_STS_USER: ${STORAGE_STS_USER}
        STORAGE_STS_PASSWORD: ${STORAGE_STS_PASSWORD}
        STORAGE_ENDPOINT: ${STORAGE_ENDPOINT}
      volumes:
        - ./infra/k8s/s3/init.sh/:/setup/init.sh
        - ./infra/k8s/s3/sts-streamtube-readonly-policy.json:/setup/sts-streamtube-readonly-policy.json    
      networks:
        - streamtube-dev
      entrypoint: ["/bin/sh", "/setup/init.sh"]
  
      
    rabbitmq:
        image: rabbitmq:4.2-management
        volumes:
          - rabbitmq-dev-data:/var/lib/rabbitmq 
        environment:
          RABBITMQ_DEFAULT_USER: ${RABBITMQ_USERNAME}
          RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASSWORD}
        ports:
          - 127.0.0.1:5672:5672
          - 127.0.0.1:15672:15672
        networks:
          - streamtube-dev
        healthcheck:
          test: ["CMD", "rabbitmq-diagnostics", "-q", "ping"]
          interval: 5s
          timeout: 5s
          retries: 5
          start_period: 10s
        restart: always

    rabbitmq-init:
        image: rabbitmq:4.2-management
        networks:
          - streamtube-dev
        depends_on:
          rabbitmq:
            condition: service_healthy
        environment:
          RABBITMQ_HOST: ${RABBITMQ_HOST}
          RABBITMQ_MANAGEMENT_PORT: ${RABBITMQ_MANAGEMENT_PORT}
          RABBITMQ_DEFAULT_USER: ${RABBITMQ_USERNAME}
          RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASSWORD}
        volumes:
          - ./infra/k8s/rabbitmq/init.sh:/usr/local/bin/init.sh:ro
        entrypoint: ["/bin/sh", "/usr/local/bin/init.sh"]
    pgadmin:
      image: dpage/pgadmin4:latest
      restart: always
      environment:
        PGADMIN_DEFAULT_EMAIL: ${PGADMIN_DEFAULT_EMAIL}
        PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_DEFAULT_PASSWORD}
      networks:
        - streamtube-dev
      ports:
        - "127.0.0.1:5050:80"
      depends_on:
        postgres:
          condition: service_healthy
      volumes:
        - pgadmin-dev-data:/var/lib/pgadmin

volumes:
  mongodb-dev-data:
  minio-dev-data:
  pg-dev-data:
  pgadmin-dev-data:
  rabbitmq-dev-data:

networks:
  streamtube-dev: